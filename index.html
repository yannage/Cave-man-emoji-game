<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Caveman Coffee: Maze Adventure</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #8B4513;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            margin: 0;
            padding: 20px;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #6B4226;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            max-width: 90vw;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(10, 40px);
            grid-template-rows: repeat(10, 40px);
            gap: 2px;
            margin-bottom: 20px;
        }
        .cell {
            width: 40px;
            height: 40px;
            background-color: #A67B5B;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            border-radius: 5px;
            position: relative;
        }
        .dino-container {
            position: relative;
            display: inline-block;
        }
        .dino-hat {
            position: absolute;
            top: -14px;
            left: 3px;
            font-size: 10px;
            transform: rotate(15deg);
        }
        .cell:hover {
            background-color: #C99C7D;
        }
        .wall {
            background-color: #228B22 !important;
        }
        .fog {
            background-color: #333 !important;
            color: transparent;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 20px;
            background-color: #5D3A1F;
            padding: 10px;
            border-radius: 5px;
        }
        .control-panel {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        button {
            background-color: #5D3A1F;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #7E5835;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #6B4226;
            padding: 20px;
            border-radius: 10px;
            max-width: 500px;
            text-align: center;
        }
        .fight-area {
            background-color: rgba(139, 69, 19, 0.95);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            min-width: 300px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        .rps-choices {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }
        .rps-choice {
            font-size: 30px;
            cursor: pointer;
            background-color: #A67B5B;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
            transition: transform 0.1s;
        }
        .rps-choice:hover {
            transform: scale(1.1);
        }
        .rps-choice.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .rps-result {
            margin-top: 15px;
            font-size: 18px;
            min-height: 20px;
        }
    </style>
</head>
<body>
    <h1>ü¶ñ Caveman Coffee: Maze Adventure ‚òï</h1>
    
    <div class="game-container">
        <div class="stats">
            <div>Lives: <span id="lives">3</span></div>
            <div>Coffee Beans: <span id="beans">0/10</span></div>
            <div>Tools: <span id="tools">ü™®</span></div>
            <div>Coffee Brewed: <span id="coffees">0</span></div>
        </div>
        
        <div id="grid" class="grid"></div>
        
        <div class="control-panel">
            <button id="start-btn">Start Game</button>
            <button id="brew-btn" disabled>Brew Coffee</button>
        </div>
    </div>
    
    <div id="fight-area" class="fight-area">
        <h2>Battle the <span id="dino-type">Dinosaur</span>!</h2>
        <p>Choose your weapon:</p>
        <div class="rps-choices">
            <div class="rps-choice" id="rock">ü™®</div>
            <div class="rps-choice disabled" id="paper">üìú</div>
            <div class="rps-choice disabled" id="scissors">‚úÇÔ∏è</div>
        </div>
        <div class="rps-result" id="rps-result"></div>
        <button id="continue-btn" style="display: none;">Continue</button>
    </div>
    
    <div id="tutorial-modal" class="modal">
        <div class="modal-content">
            <h2>How to Play</h2>
            <p>Navigate the maze to find coffee beans and bring them back to your cave!</p>
            <ul style="text-align: left;">
                <li>Click adjacent squares to move your caveman</li>
                <li>Collect coffee beans (ü´ò) and return to your cave (üè†)</li>
                <li>Find tools (‚úÇÔ∏è & üìú) to help in dinosaur battles</li>
                <li>Defeat dinosaurs with rock-paper-scissors</li>
                <li>Brew coffee to win!</li>
            </ul>
            <button id="tutorial-close">Start Game</button>
        </div>
    </div>
    
    <div id="game-over-modal" class="modal">
        <div class="modal-content">
            <h2>Game Over!</h2>
            <p>You were eaten by dinosaurs!</p>
            <p>Coffee Brewed: <span id="final-score">0</span></p>
            <button id="restart-btn">Play Again</button>
        </div>
    </div>

    <script>
        // Game state
        const gameState = {
            player: { x: 1, y: 1, emoji: 'üßî' },
            cave: { x: 8, y: 8, emoji: 'üè†' },
            maze: [],
            beans: [],
            dinosaurs: [],
            items: [],
            gridSize: 10,
            inventory: {
                beans: 0,
                tools: ['rock']
            },
            stats: {
                lives: 3,
                coffeesBrewed: 0
            },
            fighting: null,
            gameStarted: false
        };

        // Dinosaur types with hats
        const dinoTypes = [
            { emoji: 'ü¶ñ', name: 'T-Rex', preference: 'rock', sight: 3 },
            { emoji: 'ü¶ï', name: 'Brontosaurus', preference: 'paper', sight: 3 },
            { emoji: 'ü¶°', name: 'Raptor', preference: 'scissors', sight: 4 }
        ];

        // Hats array
        const hats = ['üé©', 'üß¢', 'üéì'];

        // DOM Elements
        const gridEl = document.getElementById('grid');
        const livesEl = document.getElementById('lives');
        const beansEl = document.getElementById('beans');
        const toolsEl = document.getElementById('tools');
        const coffeesEl = document.getElementById('coffees');
        const startBtn = document.getElementById('start-btn');
        const brewBtn = document.getElementById('brew-btn');
        const fightArea = document.getElementById('fight-area');
        const dinoTypeEl = document.getElementById('dino-type');
        const rpsResult = document.getElementById('rps-result');
        const continueBtn = document.getElementById('continue-btn');
        const tutorialModal = document.getElementById('tutorial-modal');
        const gameOverModal = document.getElementById('game-over-modal');
        const finalScoreEl = document.getElementById('final-score');
        const restartBtn = document.getElementById('restart-btn');
        const tutorialCloseBtn = document.getElementById('tutorial-close');
        
        // Initialize the game
        function initGame() {
            // Create the grid
            createGrid();
            
            // Set up event listeners
            startBtn.addEventListener('click', startGame);
            brewBtn.addEventListener('click', brewCoffee);
            document.getElementById('rock').addEventListener('click', () => makeChoice('rock'));
            document.getElementById('paper').addEventListener('click', () => makeChoice('paper'));
            document.getElementById('scissors').addEventListener('click', () => makeChoice('scissors'));
            continueBtn.addEventListener('click', endFight);
            restartBtn.addEventListener('click', restartGame);
            tutorialCloseBtn.addEventListener('click', () => {
                tutorialModal.style.display = 'none';
            });
            
            // Show tutorial on first load
            tutorialModal.style.display = 'flex';
        }
        
        // Create the grid
        function createGrid() {
            gridEl.innerHTML = '';
            for (let y = 0; y < gameState.gridSize; y++) {
                for (let x = 0; x < gameState.gridSize; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.addEventListener('click', () => handleCellClick(x, y));
                    gridEl.appendChild(cell);
                }
            }
        }
        
        // Start the game
        function startGame() {
            if (gameState.gameStarted) return;
            
            // Generate maze layout
            generateMaze();
            
            // Place entities
            placeEntities();
            
            // Update UI
            updateUI();
            
            // Hide start button
            startBtn.style.display = 'none';
            
            gameState.gameStarted = true;
        }
        
        // Generate maze
        function generateMaze() {
            // Create empty maze
            gameState.maze = [];
            
            // First, fill the entire maze with walls
            for (let y = 0; y < gameState.gridSize; y++) {
                const row = [];
                for (let x = 0; x < gameState.gridSize; x++) {
                    // Border walls
                    if (x === 0 || y === 0 || x === gameState.gridSize - 1 || y === gameState.gridSize - 1) {
                        row.push(1); // Wall
                    } else {
                        row.push(0); // Path
                    }
                }
                gameState.maze.push(row);
            }
            
            // Now add some internal walls (25% chance)
            for (let y = 1; y < gameState.gridSize - 1; y++) {
                for (let x = 1; x < gameState.gridSize - 1; x++) {
                    // Skip player and cave positions
                    if ((x === gameState.player.x && y === gameState.player.y) || 
                        (x === gameState.cave.x && y === gameState.cave.y)) {
                        continue;
                    }
                    
                    // 25% chance for wall
                    if (Math.random() < 0.25) {
                        gameState.maze[y][x] = 1;
                    }
                }
            }
            
            // Ensure the maze is fully connected
            ensureMazeConnectivity();
            
            // Ensure player and cave positions are paths
            gameState.maze[gameState.player.y][gameState.player.x] = 0;
            gameState.maze[gameState.cave.y][gameState.cave.x] = 0;
            
            // Ensure paths around the cave
            gameState.maze[gameState.cave.y-1][gameState.cave.x] = 0;
            gameState.maze[gameState.cave.y][gameState.cave.x-1] = 0;
        }
        
        // Ensure all path cells in the maze are connected
        function ensureMazeConnectivity() {
            // Create a copy of the maze to track visited cells
            const visited = [];
            for (let y = 0; y < gameState.gridSize; y++) {
                const row = [];
                for (let x = 0; x < gameState.gridSize; x++) {
                    row.push(false);
                }
                visited.push(row);
            }
            
            // Flood fill from player position
            const queue = [{x: gameState.player.x, y: gameState.player.y}];
            visited[gameState.player.y][gameState.player.x] = true;
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Check all four directions
                const directions = [
                    {dx: 0, dy: -1}, // Up
                    {dx: 1, dy: 0},  // Right
                    {dx: 0, dy: 1},  // Down
                    {dx: -1, dy: 0}  // Left
                ];
                
                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    
                    // Check if in bounds
                    if (nx <= 0 || ny <= 0 || nx >= gameState.gridSize - 1 || ny >= gameState.gridSize - 1) {
                        continue;
                    }
                    
                    // If it's a path and not visited, add to queue
                    if (gameState.maze[ny][nx] === 0 && !visited[ny][nx]) {
                        queue.push({x: nx, y: ny});
                        visited[ny][nx] = true;
                    }
                }
            }
            
            // Find all unvisited path cells and connect them to a visited neighbor
            for (let y = 1; y < gameState.gridSize - 1; y++) {
                for (let x = 1; x < gameState.gridSize - 1; x++) {
                    // If it's a path cell but wasn't visited
                    if (gameState.maze[y][x] === 0 && !visited[y][x]) {
                        // Find a visited neighbor
                        let foundConnection = false;
                        const directions = [
                            {dx: 0, dy: -1}, // Up
                            {dx: 1, dy: 0},  // Right
                            {dx: 0, dy: 1},  // Down
                            {dx: -1, dy: 0}  // Left
                        ];
                        
                        // Shuffle directions for randomness
                        for (let i = directions.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [directions[i], directions[j]] = [directions[j], directions[i]];
                        }
                        
                        for (const dir of directions) {
                            const nx = x + dir.dx;
                            const ny = y + dir.dy;
                            
                            if (nx <= 0 || ny <= 0 || nx >= gameState.gridSize - 1 || ny >= gameState.gridSize - 1) {
                                continue;
                            }
                            
                            // If neighbor is visited, create a path
                            if (visited[ny][nx]) {
                                // Create a path from the unvisited cell to this visited cell
                                gameState.maze[y][x] = 0;
                                
                                // If there's a wall between them, remove it
                                if (gameState.maze[ny][nx] === 1) {
                                    gameState.maze[ny][nx] = 0;
                                }
                                
                                foundConnection = true;
                                break;
                            }
                        }
                        
                        // If we couldn't find a connection, just make it a wall
                        if (!foundConnection) {
                            gameState.maze[y][x] = 1;
                        }
                    }
                }
            }
            
            // Now do a final connectivity check
            // If there are still unreachable path cells, convert them to walls
            for (let y = 1; y < gameState.gridSize - 1; y++) {
                for (let x = 1; x < gameState.gridSize - 1; x++) {
                    if (gameState.maze[y][x] === 0 && !isReachable(x, y)) {
                        gameState.maze[y][x] = 1;
                    }
                }
            }
        }
        
        // Check if a cell is reachable from the player position
        function isReachable(targetX, targetY) {
            // Create a copy of the maze to track visited cells
            const visited = [];
            for (let y = 0; y < gameState.gridSize; y++) {
                const row = [];
                for (let x = 0; x < gameState.gridSize; x++) {
                    row.push(false);
                }
                visited.push(row);
            }
            
            // Flood fill from player position
            const queue = [{x: gameState.player.x, y: gameState.player.y}];
            visited[gameState.player.y][gameState.player.x] = true;
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Check if we've reached the target
                if (current.x === targetX && current.y === targetY) {
                    return true;
                }
                
                // Check all four directions
                const directions = [
                    {dx: 0, dy: -1}, // Up
                    {dx: 1, dy: 0},  // Right
                    {dx: 0, dy: 1},  // Down
                    {dx: -1, dy: 0}  // Left
                ];
                
                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    
                    // Check if in bounds
                    if (nx < 0 || ny < 0 || nx >= gameState.gridSize || ny >= gameState.gridSize) {
                        continue;
                    }
                    
                    // If it's a path and not visited, add to queue
                    if (gameState.maze[ny][nx] === 0 && !visited[ny][nx]) {
                        queue.push({x: nx, y: ny});
                        visited[ny][nx] = true;
                    }
                }
            }
            
            // If we've exhausted the queue without finding the target, it's not reachable
            return false;
        }
        
        // Place entities in the maze
        function placeEntities() {
            // Clear entities
            gameState.beans = [];
            gameState.dinosaurs = [];
            gameState.items = [];
            
            // Place beans (10-15)
            for (let i = 0; i < 15; i++) {
                const pos = findEmptyCell();
                if (pos) {
                    gameState.beans.push({ x: pos.x, y: pos.y, emoji: 'ü´ò' });
                }
            }
            
            // Place dinosaurs (3)
            for (let i = 0; i < 3; i++) {
                const pos = findEmptyCell();
                if (pos) {
                    const dinoType = dinoTypes[i % dinoTypes.length];
                    // Add a random hat to the dinosaur
                    const randomHat = hats[Math.floor(Math.random() * hats.length)];
                    // We'll display the dinosaur and hat separately in the UI
                    
                    gameState.dinosaurs.push({
                        x: pos.x,
                        y: pos.y,
                        emoji: dinoType.emoji,
                        type: dinoType.name,
                        preference: dinoType.preference,
                        hat: randomHat
                    });
                }
            }
            
            // Place scissors
            const scissorsPos = findEmptyCell();
            if (scissorsPos) {
                gameState.items.push({ 
                    x: scissorsPos.x, 
                    y: scissorsPos.y, 
                    emoji: '‚úÇÔ∏è', 
                    type: 'scissors' 
                });
            }
            
            // Place paper
            const paperPos = findEmptyCell();
            if (paperPos) {
                gameState.items.push({ 
                    x: paperPos.x, 
                    y: paperPos.y, 
                    emoji: 'üìú', 
                    type: 'paper' 
                });
            }
        }
        
        // Find an empty cell in the maze
        function findEmptyCell() {
            let attempts = 0;
            
            while (attempts < 50) {
                const x = Math.floor(Math.random() * (gameState.gridSize - 2)) + 1;
                const y = Math.floor(Math.random() * (gameState.gridSize - 2)) + 1;
                
                // Check if it's a path and not occupied
                if (gameState.maze[y][x] === 0 && isEmptyCell(x, y)) {
                    return { x, y };
                }
                
                attempts++;
            }
            
            return null;
        }
        
        // Check if a cell is empty
        function isEmptyCell(x, y) {
            // Check player
            if (gameState.player.x === x && gameState.player.y === y) return false;
            
            // Check cave
            if (gameState.cave.x === x && gameState.cave.y === y) return false;
            
            // Check beans
            if (gameState.beans.some(bean => bean.x === x && bean.y === y)) return false;
            
            // Check dinosaurs
            if (gameState.dinosaurs.some(dino => dino.x === x && dino.y === y)) return false;
            
            // Check items
            if (gameState.items.some(item => item.x === x && item.y === y)) return false;
            
            return true;
        }
        
        // Handle cell click
        function handleCellClick(x, y) {
            if (!gameState.gameStarted || gameState.fighting) return;
            
            // Check if adjacent to player
            const dx = Math.abs(x - gameState.player.x);
            const dy = Math.abs(y - gameState.player.y);
            
            // Must be adjacent (non-diagonal) and not a wall
            if (dx + dy === 1 && gameState.maze[y][x] === 0) {
                movePlayer(x, y);
            }
        }
        
        // Move player
        function movePlayer(x, y) {
            // Update player position
            gameState.player.x = x;
            gameState.player.y = y;
            
            // Check for collisions
            checkCollisions();
            
            // Move dinosaurs
            moveDinosaurs();
            
            // Check for dinosaur collisions
            checkDinosaurCollisions();
            
            // Update UI
            updateUI();
        }
        
        // Check for collisions with items/beans
        function checkCollisions() {
            // Check for bean collision
            const beanIndex = gameState.beans.findIndex(bean => 
                bean.x === gameState.player.x && bean.y === gameState.player.y
            );
            
            if (beanIndex !== -1) {
                gameState.inventory.beans++;
                gameState.beans.splice(beanIndex, 1);
            }
            
            // Check for item collision
            const itemIndex = gameState.items.findIndex(item => 
                item.x === gameState.player.x && item.y === gameState.player.y
            );
            
            if (itemIndex !== -1) {
                const item = gameState.items[itemIndex];
                
                if (!gameState.inventory.tools.includes(item.type)) {
                    gameState.inventory.tools.push(item.type);
                }
                
                gameState.items.splice(itemIndex, 1);
                
                // Update tool visibility in fight area
                updateToolAvailability();
            }
            
            // Check if at cave
            if (gameState.player.x === gameState.cave.x && gameState.player.y === gameState.cave.y) {
                brewBtn.disabled = gameState.inventory.beans < 10;
                // Show how many beans you have and how many you need
                if (gameState.inventory.beans < 10) {
                    beansEl.innerHTML = `<span style="color: ${gameState.inventory.beans >= 5 ? 'gold' : 'salmon'}">${gameState.inventory.beans}/10</span>`;
                } else {
                    beansEl.innerHTML = `<span style="color: lightgreen">${gameState.inventory.beans}/10</span>`;
                }
            } else {
                brewBtn.disabled = true;
                beansEl.textContent = gameState.inventory.beans + '/10';
            }
        }
        
        // Update tool availability in the fight area
        function updateToolAvailability() {
            document.getElementById('rock').classList.toggle('disabled', !gameState.inventory.tools.includes('rock'));
            document.getElementById('paper').classList.toggle('disabled', !gameState.inventory.tools.includes('paper'));
            document.getElementById('scissors').classList.toggle('disabled', !gameState.inventory.tools.includes('scissors'));
        }
        
        // Check for collisions with dinosaurs
        function checkDinosaurCollisions() {
            for (let i = 0; i < gameState.dinosaurs.length; i++) {
                const dino = gameState.dinosaurs[i];
                
                if (dino.x === gameState.player.x && dino.y === gameState.player.y) {
                    // Start fight
                    startFight(dino);
                    break;
                }
            }
        }
        
        // Move dinosaurs
        function moveDinosaurs() {
            gameState.dinosaurs.forEach(dino => {
                // Simple movement - move randomly with 50% chance
                if (Math.random() < 0.5) {
                    // Possible directions: up, right, down, left
                    const directions = [
                        { dx: 0, dy: -1 },
                        { dx: 1, dy: 0 },
                        { dx: 0, dy: 1 },
                        { dx: -1, dy: 0 }
                    ];
                    
                    // Shuffle directions
                    for (let i = directions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [directions[i], directions[j]] = [directions[j], directions[i]];
                    }
                    
                    // Try each direction
                    for (const dir of directions) {
                        const newX = dino.x + dir.dx;
                        const newY = dino.y + dir.dy;
                        
                        // Check if valid move
                        if (newX > 0 && newX < gameState.gridSize - 1 && 
                            newY > 0 && newY < gameState.gridSize - 1 && 
                            gameState.maze[newY][newX] === 0 && 
                            isEmptyCell(newX, newY)) {
                            
                            dino.x = newX;
                            dino.y = newY;
                            break;
                        }
                    }
                }
            });
        }
        
        // Start fight with dinosaur
        function startFight(dino) {
            gameState.fighting = dino;
            
            // Custom intro based on hat type
            let introText;
            if (dino.hat === 'üé©') {
                introText = `${dino.type} Gentleman`;
            } else if (dino.hat === 'üéì') {
                introText = `Burnt-out Graduate ${dino.type}`;
            } else if (dino.hat === 'üß¢') {
                introText = `Punk ${dino.type}`;
            }
            
            dinoTypeEl.textContent = introText;
            rpsResult.textContent = '';
            continueBtn.style.display = 'none';
            updateToolAvailability();
            fightArea.style.display = 'block';
        }
        
        // Make a choice in rock-paper-scissors
        function makeChoice(playerChoice) {
            if (!gameState.fighting || !gameState.inventory.tools.includes(playerChoice)) return;
            
            // Get dinosaur choice
            const dinoChoice = getDinoChoice();
            
            // Determine winner
            let result;
            if (playerChoice === dinoChoice) {
                result = 'draw';
            } else if (
                (playerChoice === 'rock' && dinoChoice === 'scissors') ||
                (playerChoice === 'paper' && dinoChoice === 'rock') ||
                (playerChoice === 'scissors' && dinoChoice === 'paper')
            ) {
                result = 'win';
            } else {
                result = 'lose';
            }
            
            // Show result
            let resultHTML = '';
            const playerEmoji = playerChoice === 'rock' ? 'ü™®' : playerChoice === 'paper' ? 'üìú' : '‚úÇÔ∏è';
            const dinoEmoji = dinoChoice === 'rock' ? 'ü™®' : dinoChoice === 'paper' ? 'üìú' : '‚úÇÔ∏è';
            
            resultHTML += `You chose ${playerEmoji} | Dino chose ${dinoEmoji}<br>`;
            
            // Get custom dialogue based on hat type
            const hat = gameState.fighting.hat;
            
            if (result === 'win') {
                if (hat === 'üé©') {
                    resultHTML += '<span style="color: lightgreen">You win! "I say, jolly good show! I shall retreat with dignity," says the dinosaur as it tips its top hat and walks away.</span>';
                } else if (hat === 'üéì') {
                    resultHTML += '<span style="color: lightgreen">You win! "Whatever. I didn\'t even study for this fight," sighs the burnt-out graduate dinosaur as it trudges away.</span>';
                } else if (hat === 'üß¢') {
                    resultHTML += '<span style="color: lightgreen">You win! "This is SO unfair! I\'ll get you next time!" yells the punk dinosaur as it stomps away angrily.</span>';
                }
            } else if (result === 'lose') {
                if (hat === 'üé©') {
                    resultHTML += '<span style="color: salmon">You lose! "I do apologize for the inconvenience, but I must insist on eating you now," says the gentleman dinosaur, adjusting its monocle.</span>';
                } else if (hat === 'üéì') {
                    resultHTML += '<span style="color: salmon">You lose! "I\'ve got student loans to pay. Nothing personal," mumbles the graduate dinosaur with dead eyes.</span>';
                } else if (hat === 'üß¢') {
                    resultHTML += '<span style="color: salmon">You lose! "HA! Take that, cave-loser! Who\'s the apex predator NOW?" taunts the punk dinosaur, high-fiving its tail.</span>';
                }
            } else {
                if (hat === 'üé©') {
                    resultHTML += '<span style="color: gold">It\'s a draw! "A stalemate! How intriguing. Shall we try again?" says the gentleman dinosaur, tipping its hat politely.</span>';
                } else if (hat === 'üéì') {
                    resultHTML += '<span style="color: gold">It\'s a draw! "Can we just call it a day? I\'ve got papers to grade," sighs the graduate dinosaur, looking at its watch.</span>';
                } else if (hat === 'üß¢') {
                    resultHTML += '<span style="color: gold">It\'s a draw! "BOOORING! Play for real or go home!" the punk dinosaur shouts while dramatically rolling its eyes.</span>';
                }
                continueBtn.style.display = 'none';
                rpsResult.innerHTML = resultHTML;
                return;
            }
            
            rpsResult.innerHTML = resultHTML;
            continueBtn.style.display = 'inline-block';
        }
        
        // Get dinosaur choice
        function getDinoChoice() {
            const dino = gameState.fighting;
            const rand = Math.random();
            
            // 60% chance to use preferred choice
            if (rand < 0.6) {
                return dino.preference;
            }
            
            // 40% chance for random choice
            const choices = ['rock', 'paper', 'scissors'];
            const otherChoices = choices.filter(c => c !== dino.preference);
            return otherChoices[Math.floor(Math.random() * otherChoices.length)];
        }
        
        // End fight
        function endFight() {
            const resultText = rpsResult.textContent.toLowerCase();
            
            if (resultText.includes('win')) {
                // Remove dinosaur
                const index = gameState.dinosaurs.findIndex(d => d === gameState.fighting);
                if (index !== -1) {
                    gameState.dinosaurs.splice(index, 1);
                }
            } else if (resultText.includes('lose')) {
                // Lose a life
                gameState.stats.lives--;
                
                // Game over if no lives left
                if (gameState.stats.lives <= 0) {
                    gameOver();
                    return;
                }
                
                // Move player back to start
                gameState.player.x = 1;
                gameState.player.y = 1;
            }
            
            // Hide fight area
            fightArea.style.display = 'none';
            gameState.fighting = null;
            
            // Update UI
            updateUI();
        }
        
        // Brew coffee
        function brewCoffee() {
            if (gameState.inventory.beans < 10 || 
                gameState.player.x !== gameState.cave.x || 
                gameState.player.y !== gameState.cave.y) return;
            
            // Use beans
            gameState.inventory.beans -= 10;
            
            // Increment coffee count
            gameState.stats.coffeesBrewed++;
            
            // Calculate how many beans to spawn to reach 15 total
            const beansToSpawn = 15 - gameState.beans.length;
            
            // Respawn beans up to 15 total
            for (let i = 0; i < beansToSpawn; i++) {
                const pos = findEmptyCell();
                if (pos) {
                    gameState.beans.push({ x: pos.x, y: pos.y, emoji: 'ü´ò' });
                }
            }
            
            // Spawn new dinosaurs (up to 3 total)
            const dinosToSpawn = 3 - gameState.dinosaurs.length;
            for (let i = 0; i < dinosToSpawn; i++) {
                const pos = findEmptyCell();
                if (pos) {
                    const dinoType = dinoTypes[Math.floor(Math.random() * dinoTypes.length)];
                    const randomHat = hats[Math.floor(Math.random() * hats.length)];
                    
                    gameState.dinosaurs.push({
                        x: pos.x,
                        y: pos.y,
                        emoji: dinoType.emoji,
                        type: dinoType.name,
                        preference: dinoType.preference,
                        hat: randomHat
                    });
                }
            }
            
            // Update UI
            updateUI();
        }
        
        // Game over
        function gameOver() {
            finalScoreEl.textContent = gameState.stats.coffeesBrewed;
            gameOverModal.style.display = 'flex';
            fightArea.style.display = 'none';
        }
        
        // Restart game
        function restartGame() {
            // Reset game state
            gameState.player = { x: 1, y: 1, emoji: 'üßî' };
            gameState.beans = [];
            gameState.dinosaurs = [];
            gameState.items = [];
            gameState.inventory.beans = 0;
            gameState.inventory.tools = ['rock'];
            gameState.stats.lives = 3;
            gameState.stats.coffeesBrewed = 0;
            gameState.fighting = null;
            
            // Hide modals
            gameOverModal.style.display = 'none';
            
            // Restart game
            startGame();
        }
        
        // Update UI
        function updateUI() {
            // Update stats
            livesEl.textContent = gameState.stats.lives;
            // Bean count is handled in checkCollisions
            if (!(gameState.player.x === gameState.cave.x && gameState.player.y === gameState.cave.y)) {
                beansEl.textContent = gameState.inventory.beans + '/10';
            }
            coffeesEl.textContent = gameState.stats.coffeesBrewed;
            
            // Update tools display
            toolsEl.textContent = gameState.inventory.tools.map(tool => {
                return tool === 'rock' ? 'ü™®' : tool === 'paper' ? 'üìú' : '‚úÇÔ∏è';
            }).join(' ');
            
            // Enable/disable brew button
            brewBtn.disabled = !(gameState.inventory.beans >= 10 && 
                                gameState.player.x === gameState.cave.x && 
                                gameState.player.y === gameState.cave.y);
            
            // Render grid
            renderGrid();
        }
        
        // Render the grid
        function renderGrid() {
            // First reset all cells
            document.querySelectorAll('.cell').forEach(cell => {
                cell.innerHTML = '';
                cell.className = 'cell';
                
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                
                if (gameState.maze[y][x] === 1) {
                    cell.classList.add('wall');
                    cell.textContent = 'üåø';
                }
            });
            
            // Render cave
            const caveCell = document.querySelector(`.cell[data-x="${gameState.cave.x}"][data-y="${gameState.cave.y}"]`);
            if (caveCell) {
                caveCell.textContent = gameState.cave.emoji;
            }
            
            // Render beans
            gameState.beans.forEach(bean => {
                const cell = document.querySelector(`.cell[data-x="${bean.x}"][data-y="${bean.y}"]`);
                if (cell) {
                    cell.textContent = bean.emoji;
                }
            });
            
            // Render items
            gameState.items.forEach(item => {
                const cell = document.querySelector(`.cell[data-x="${item.x}"][data-y="${item.y}"]`);
                if (cell) {
                    cell.textContent = item.emoji;
                }
            });
            
            // Render dinosaurs with hats
            gameState.dinosaurs.forEach(dino => {
                const cell = document.querySelector(`.cell[data-x="${dino.x}"][data-y="${dino.y}"]`);
                if (cell) {
                    // Create a container for the dinosaur and hat
                    const dinoContainer = document.createElement('div');
                    dinoContainer.className = 'dino-container';
                    
                    // Add the dinosaur emoji
                    dinoContainer.textContent = dino.emoji;
                    
                    // Add the hat as a child element
                    const hatElement = document.createElement('div');
                    hatElement.className = 'dino-hat';
                    hatElement.textContent = dino.hat;
                    dinoContainer.appendChild(hatElement);
                    
                    // Clear the cell and add the container
                    cell.innerHTML = '';
                    cell.appendChild(dinoContainer);
                }
            });
            
            // Render player (on top of everything)
            const playerCell = document.querySelector(`.cell[data-x="${gameState.player.x}"][data-y="${gameState.player.y}"]`);
            if (playerCell) {
                playerCell.textContent = gameState.player.emoji;
            }
        }
        
        // Initialize game on load
        window.onload = initGame;
    </script>
</body>
</html>